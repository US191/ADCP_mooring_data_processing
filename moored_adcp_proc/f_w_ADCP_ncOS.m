function f_w_ADCP_ncOS(tc_filenamin,cell_Attributes,struct_ADCP,d_fillval)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function to write ADCP mooring current post-processed fields into NetCDF file format following OceanSites requirements.
%
%  INPUTS : 
%           tc_filenamin    : output NETCDF file name including path
%           cell_Attributes : cell array containing global attribute informations needed to create NETCDF file 
%                             (attributes read previously from xls file)
%           struct_ADCP     : structure array with ADCP data (U,V), dimensions (TIME,DEPTH) and mooring name 
%                             and positions (Name of the fields are: mooringName,mooringLat,mooringLon,time,depth,u,v)
%           d_fillval       : numeric value to specify fill value. 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Authors : Jerome LLIDO IRD/LEGOS
%           Pierre Rousselot IRD/US-IMAGO
%
% Date    : 26/11/2020
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% TEST INPUT ARGUMENTS %%
if nargin < 4
    error('MATLAB:notEnoughInputs',...
        '\nNot enough input arguments.');   
end
if ~ischar(tc_filenamin)
    error('MyComponent:incorrectType',...
       '\nFirst input argument must be a char, not a %s.',class(tc_filenamin));
end
if ~iscell(cell_Attributes)
    error('MyComponent:incorrectType',...
       '\nSecond input argument must be a cell, not a %s.',class(cell_Attributes));
end
if ~isstruct(struct_ADCP)
    error('MyComponent:incorrectType',...
       '\nThird input argument must be a structure, not a %s.',class(struct_ADCP));
elseif ~all(isfield(struct_ADCP,{'mooringName','mooringLat','mooringLon','time','depth','u','v'}))
    error('\nCheck the field names of the structure array %s. \n Fields : time, depth, mooringLat, mooringLon, u and v required.',class(struct_ADCP));
end
if ~isnumeric(d_fillval)
    error('MyComponent:incorrectType',...
       '\nLast input argument must be a numeric value, not a %s.',class(d_fillval));
end

%% Get start and final dates of mooring data %%
ti_startDate=julian(struct_ADCP.time(1,1));%datevec(struct_ADCP.time(1,1)+datenum(1950,01,01));%
ti_finalDate=julian(struct_ADCP.time(length(struct_ADCP.time)));%datevec(struct_ADCP.time(length(struct_ADCP.time))+datenum(1950,01,01));%

% Convert initial time from Julian Days (JD) beginning at 0000 hours, May 23, 1968 (as initialy created) to days numbers (JD) to be used as started at 0000 hours on January 01, 1950 %%
ti_timeJulD=struct_ADCP.time;
ti_timeJ=ones(1,numel(ti_timeJulD)) * NaN;
for it=1:numel(ti_timeJulD)
    ti_timeJ(it)=days(datetime(ti_timeJulD(it)-0.5,'ConvertFrom','juliandate') - datetime(1950,1,1,0,0,0));  % -0.5 is necessary to remove 12h00 introduced by datetime function starting at noon instead of midnight as performed by julian function previously used 
end
struct_ADCP.time=ti_timeJ;%struct_ADCP.time';

%% Find and replace NaN by FillValue in all variables %%
% Test and replace NaN (if needed) in variable dimensions (TIME, DEPTH, LATITUDE, LONGITUDE) %
if ~isempty(find(isnan(struct_ADCP.time)))
    struct_ADCP.time(find(isnan(struct_ADCP.time)))=d_fillval;
end
if ~isempty(find(isnan(struct_ADCP.depth)))
    struct_ADCP.time(find(isnan(struct_ADCP.depth)))=d_fillval;
end
if ~isempty(find(isnan(struct_ADCP.mooringLat)))
    struct_ADCP.time(find(isnan(struct_ADCP.mooringLat)))=d_fillval;
end
if ~isempty(find(isnan(struct_ADCP.mooringLon)))
    struct_ADCP.time(find(isnan(struct_ADCP.mooringLon)))=d_fillval;
end    
% Find and replace NaN by FillValue in U,V ADCP fields %
struct_ADCP.u(find(isnan(struct_ADCP.u)))=d_fillval;
struct_ADCP.v(find(isnan(struct_ADCP.v)))=d_fillval;

%% Create NetCDF file %% 
ncid_ADCP = netcdf.create(tc_filenamin,'CLOBBER');    % NOCLOBBER must be used to prevent overwritting of existing file

%% Define Dimensions %%
i_dimTime  = netcdf.defDim(ncid_ADCP,'TIME',length(struct_ADCP.time));
i_dimDepth = netcdf.defDim(ncid_ADCP,'DEPTH',length(struct_ADCP.depth));
i_dimLat   = netcdf.defDim(ncid_ADCP,'LATITUDE',length(struct_ADCP.mooringLat));
i_dimLon   = netcdf.defDim(ncid_ADCP,'LONGITUDE',length(struct_ADCP.mooringLon));

%% Create Netcdf Global Attributes %%

for j=1:length(cell_Attributes)
    % Test attribute's name to fill in time_coverage_start, time_coverage_end and geospatial lat_min, lat_max, lon_min and lon_max %
    if strcmp(cell_Attributes{j,1},'time_coverage_start')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'), 'time_coverage_start', [num2str(ti_startDate(1)) '-' num2str(ti_startDate(2),'%02d')...
     '-' num2str(ti_startDate(3),'%02d') 'T' num2str(ti_startDate(4),'%02d') ':' num2str(ti_startDate(5),'%02d') ':' num2str(ti_startDate(6),'%02d') 'Z']);
    elseif strcmp(cell_Attributes{j,1},'time_coverage_end')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'), 'time_coverage_end', [num2str(ti_finalDate(1)) '-' num2str(ti_finalDate(2),'%02d')...
     '-' num2str(ti_finalDate(3),'%02d') 'T' num2str(ti_finalDate(4),'%02d') ':' num2str(ti_finalDate(5),'%02d') ':' num2str(ti_finalDate(6),'%02d') 'Z']);
    elseif strcmp(cell_Attributes{j,1},'geospatial_lat_min')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'),'geospatial_lat_min',struct_ADCP.mooringLat);
    elseif strcmp(cell_Attributes{j,1},'geospatial_lat_max')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'),'geospatial_lat_max',struct_ADCP.mooringLat);
    elseif strcmp(cell_Attributes{j,1},'geospatial_lon_min')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'),'geospatial_lon_min',struct_ADCP.mooringLon);
    elseif strcmp(cell_Attributes{j,1},'geospatial_lon_max')
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'),'geospatial_lon_max',struct_ADCP.mooringLon);     
    else
        netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'),cell_Attributes{j,1},cell_Attributes{j,2});
    end 
end % end loop j
% Add creation date
netcdf.putAtt(ncid_ADCP, netcdf.getConstant('NC_GLOBAL'), 'date_created', datestr(now, 'yyyy-mm-ddTHH:MM:SSZ'));

%% Create Netcdf Variables & Attributes %%
% Coordinate Variables %
f_creer_newvar2(ncid_ADCP, 'TIME', 'NC_DOUBLE', i_dimTime,...
    'standard_name', 'time',...
    'units', 'days since 1950-01-01 00:00:00 UTC',...       
    'axis', 'T',...
    'long_name','time of measurement',...
    'valid_min', 0.0, 'valid_max', 90000.0,...
    '_FillValue', double(d_fillval),...
    'QC_indicator','good data',...     
    'Processing_level','Data interpolated'); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY  

f_creer_newvar2(ncid_ADCP, 'DEPTH', 'NC_FLOAT', i_dimDepth,...
    'standard_name', 'depth',...
    'units', 'meters',...
    'positive', 'down',...
    'axis', 'Z',...
    'reference', 'sea_level',...
    'coordinate_reference_frame', 'urn:ogc:def:crs:EPSG::5831',...
    '_FillValue', single(d_fillval),...  
    'long_name', 'depth of measurement',...
    'valid_min', 0, 'valid_max', 12000,...
    'QC_indicator','good data',...     
    'Processing_level','Data interpolated'); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY

f_creer_newvar2(ncid_ADCP, 'LATITUDE', 'NC_FLOAT', i_dimLat,...
    'standard_name', 'latitude',...
    'units', 'degrees_north',...
    'axis', 'Y',...
    'long_name', 'latitude of measurement',...
    'reference', 'WGS84',...
    'coordinate_reference_frame', 'urn:ogc:def:crs:EPSG::4326',...
    'valid_min', -90.0, 'valid_max', 90.0,...
    '_FillValue', single(d_fillval),...
    'QC_indicator','good data',...     
    'Processing_level','Data interpolated'); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY

f_creer_newvar2(ncid_ADCP, 'LONGITUDE', 'NC_FLOAT', i_dimLon,...
    'standard_name', 'longitude',...
    'units', 'degrees_east',...
    'axis', 'X',...
    'long_name', 'longitude of measurement',...
    'reference', 'WGS84',...
    'coordinate_reference_frame', 'urn:ogc:def:crs:EPSG::4326',...
    'valid_min', -180.0, 'valid_max', 180.0,...
    '_FillValue', single(d_fillval),...
    'QC_indicator','good data',...    
    'Processing_level','Data interpolated'); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY

% Data Variables %
f_creer_newvar2(ncid_ADCP, 'UCUR', 'NC_FLOAT', [i_dimTime, i_dimDepth, i_dimLat, i_dimLon],...
    'standard_name', 'eastward velocity',...
    'units', 'm/s',...
    '_FillValue', single(d_fillval),...
    'coordinates','TIME DEPTH LATITUDE LONGITUDE',...
    'long_name', 'eastward sea water velocity',...
    'QC_indicator','good data',...     
    'processing_level','Data interpolated',... 
    'valid_min' ,-12, 'valid_max', 12); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY

f_creer_newvar2(ncid_ADCP, 'VCUR', 'NC_FLOAT', [i_dimTime, i_dimDepth, i_dimLat, i_dimLon],...
    'standard_name', 'northward velocity',...
    'units', 'm/s',...
    '_FillValue', single(d_fillval),...
    'coordinates','TIME DEPTH LATITUDE LONGITUDE',...
    'long_name', 'northward sea water velocity',...
    'QC_indicator','good data',...     
    'processing_level','Data interpolated',... 
    'valid_min' ,-12, 'valid_max', 12); %% JLL 16/12/2020 : 'accuracy': ATTRIBUTE TO BE ADDED IF NECESSARY

netcdf.endDef(ncid_ADCP); % End Netcdf variables definition

%% Write/Store Dimensions and Variables in Netcdf file 
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'TIME'),struct_ADCP.time);
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'DEPTH'),struct_ADCP.depth);
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'LATITUDE'),struct_ADCP.mooringLat);
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'LONGITUDE'),struct_ADCP.mooringLon);
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'UCUR'),struct_ADCP.u); 
netcdf.putVar(ncid_ADCP, netcdf.inqVarID(ncid_ADCP,'VCUR'),struct_ADCP.v); 

%% Close NetCDF file %%
netcdf.close(ncid_ADCP);

end
